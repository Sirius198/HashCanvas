// tslint:disable
/**
 * Hashcanvas
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface ChangePasswordIN
 */
export interface ChangePasswordIN {
    /**
     *
     * @type {string}
     * @memberof ChangePasswordIN
     */
    currentPassword: string;
    /**
     *
     * @type {string}
     * @memberof ChangePasswordIN
     */
    newPassword: string;
}
/**
 *
 * @export
 * @interface CoinStats
 */
export interface CoinStats {
    /**
     *
     * @type {string}
     * @memberof CoinStats
     */
    provider: string;
    /**
     *
     * @type {string}
     * @memberof CoinStats
     */
    exchange: string;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    position: number;
    /**
     *
     * @type {string}
     * @memberof CoinStats
     */
    coin: string;
    /**
     *
     * @type {string}
     * @memberof CoinStats
     */
    symbol: string;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    price: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    delta1h: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    delta24h: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    delta7d: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    volume24h: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    mktCap: number;
    /**
     *
     * @type {string}
     * @memberof CoinStats
     */
    last7Days: string;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    allTimeHigherPrice: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    sinceAllTimeHiger: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    allTimeHihgDate: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    stars: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    forks: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    wathchers: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    contributors: number;
    /**
     *
     * @type {string}
     * @memberof CoinStats
     */
    commitLast4weeks: string;
    /**
     *
     * @type {string}
     * @memberof CoinStats
     */
    codeChanges: string;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    redditSubscribers: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    telegramUsers: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    fBLikes: number;
    /**
     *
     * @type {number}
     * @memberof CoinStats
     */
    twitterFollowers: number;
}
/**
 *
 * @export
 * @interface CoinsOut
 */
export interface CoinsOut {
    /**
     *
     * @type {Array<CoinStats>}
     * @memberof CoinsOut
     */
    coins: Array<CoinStats>;
}
/**
 *
 * @export
 * @interface DeleteAllSubscriptionsOut
 */
export interface DeleteAllSubscriptionsOut {
    /**
     *
     * @type {string}
     * @memberof DeleteAllSubscriptionsOut
     */
    msg: string;
}
/**
 *
 * @export
 * @interface DeleteSubscriptionIn
 */
export interface DeleteSubscriptionIn {
    /**
     *
     * @type {string}
     * @memberof DeleteSubscriptionIn
     */
    subscription_id: string;
}
/**
 *
 * @export
 * @interface DeleteSubscriptionOut
 */
export interface DeleteSubscriptionOut {
    /**
     *
     * @type {string}
     * @memberof DeleteSubscriptionOut
     */
    msg: string;
}
/**
 *
 * @export
 * @interface ErrorOUT
 */
export interface ErrorOUT {
    /**
     *
     * @type {string}
     * @memberof ErrorOUT
     */
    error: string;
}
/**
 *
 * @export
 * @interface ForgotPasswordIN
 */
export interface ForgotPasswordIN {
    /**
     *
     * @type {string}
     * @memberof ForgotPasswordIN
     */
    loginOrEmail: string;
}
/**
 *
 * @export
 * @interface GetUserOUT
 */
export interface GetUserOUT {
    /**
     *
     * @type {string}
     * @memberof GetUserOUT
     */
    login: string;
    /**
     *
     * @type {string}
     * @memberof GetUserOUT
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof GetUserOUT
     */
    createdOn: string;
}
/**
 *
 * @export
 * @interface ListSubsConf
 */
export interface ListSubsConf {
    /**
     *
     * @type {string}
     * @memberof ListSubsConf
     */
    subscriptionPairs: string;
    /**
     *
     * @type {string}
     * @memberof ListSubsConf
     */
    timeFrames: string;
}
/**
 *
 * @export
 * @interface ListSubscriptionOut
 */
export interface ListSubscriptionOut {
    /**
     *
     * @type {Array<SubscriptionExt>}
     * @memberof ListSubscriptionOut
     */
    subscription: Array<SubscriptionExt>;
}
/**
 *
 * @export
 * @interface LoginIN
 */
export interface LoginIN {
    /**
     *
     * @type {string}
     * @memberof LoginIN
     */
    loginOrEmail: string;
    /**
     *
     * @type {string}
     * @memberof LoginIN
     */
    password: string;
    /**
     *
     * @type {number}
     * @memberof LoginIN
     */
    apiKeyValidHours?: number;
}
/**
 *
 * @export
 * @interface LoginOUT
 */
export interface LoginOUT {
    /**
     *
     * @type {string}
     * @memberof LoginOUT
     */
    apiKey: string;
}
/**
 *
 * @export
 * @interface PasswordResetIN
 */
export interface PasswordResetIN {
    /**
     *
     * @type {string}
     * @memberof PasswordResetIN
     */
    code: string;
    /**
     *
     * @type {string}
     * @memberof PasswordResetIN
     */
    password: string;
}
/**
 *
 * @export
 * @interface ProvidersCoinsOut
 */
export interface ProvidersCoinsOut {
    /**
     *
     * @type {string}
     * @memberof ProvidersCoinsOut
     */
    providers: string;
    /**
     *
     * @type {Array<CoinStats>}
     * @memberof ProvidersCoinsOut
     */
    coins: Array<CoinStats>;
}
/**
 *
 * @export
 * @interface ProvidersDetails
 */
export interface ProvidersDetails {
    /**
     *
     * @type {string}
     * @memberof ProvidersDetails
     */
    providerDetails_id: string;
    /**
     *
     * @type {string}
     * @memberof ProvidersDetails
     */
    provider: string;
    /**
     *
     * @type {string}
     * @memberof ProvidersDetails
     */
    exchange: string;
    /**
     *
     * @type {string}
     * @memberof ProvidersDetails
     */
    typeExchange: string;
    /**
     *
     * @type {number}
     * @memberof ProvidersDetails
     */
    volume24h: number;
    /**
     *
     * @type {number}
     * @memberof ProvidersDetails
     */
    coinsQty: number;
    /**
     *
     * @type {number}
     * @memberof ProvidersDetails
     */
    pairsQty: number;
    /**
     *
     * @type {string}
     * @memberof ProvidersDetails
     */
    last7days: string;
    /**
     *
     * @type {string}
     * @memberof ProvidersDetails
     */
    country: string;
    /**
     *
     * @type {number}
     * @memberof ProvidersDetails
     */
    twitterFolowers: number;
    /**
     *
     * @type {number}
     * @memberof ProvidersDetails
     */
    alexaRank: number;
    /**
     *
     * @type {boolean}
     * @memberof ProvidersDetails
     */
    active: boolean;
    /**
     *
     * @type {string}
     * @memberof ProvidersDetails
     */
    created_on: string;
}
/**
 *
 * @export
 * @interface ProvidersListOut
 */
export interface ProvidersListOut {
    /**
     *
     * @type {Array<string>}
     * @memberof ProvidersListOut
     */
    list: Array<string>;
}
/**
 *
 * @export
 * @interface ProvidersOut
 */
export interface ProvidersOut {
    /**
     *
     * @type {Array<ProvidersDetails>}
     * @memberof ProvidersOut
     */
    exchanges: Array<ProvidersDetails>;
}
/**
 *
 * @export
 * @interface RegisterIN
 */
export interface RegisterIN {
    /**
     *
     * @type {string}
     * @memberof RegisterIN
     */
    login: string;
    /**
     *
     * @type {string}
     * @memberof RegisterIN
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof RegisterIN
     */
    password: string;
}
/**
 *
 * @export
 * @interface RegisterOUT
 */
export interface RegisterOUT {
    /**
     *
     * @type {string}
     * @memberof RegisterOUT
     */
    apiKey: string;
}
/**
 *
 * @export
 * @interface StrategyDefinition
 */
export interface StrategyDefinition {
    /**
     *
     * @type {string}
     * @memberof StrategyDefinition
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof StrategyDefinition
     */
    strategies: string;
    /**
     *
     * @type {string}
     * @memberof StrategyDefinition
     */
    strategies_description: string;
    /**
     *
     * @type {string}
     * @memberof StrategyDefinition
     */
    image_url: string;
    /**
     *
     * @type {string}
     * @memberof StrategyDefinition
     */
    created_on: string;
}
/**
 *
 * @export
 * @interface StrategyDetails
 */
export interface StrategyDetails {
    /**
     *
     * @type {string}
     * @memberof StrategyDetails
     */
    strategyId: string;
    /**
     *
     * @type {string}
     * @memberof StrategyDetails
     */
    pair: string;
    /**
     *
     * @type {string}
     * @memberof StrategyDetails
     */
    shape: string;
    /**
     *
     * @type {boolean}
     * @memberof StrategyDetails
     */
    state: boolean;
}
/**
 *
 * @export
 * @interface StrategyDetailsIn
 */
export interface StrategyDetailsIn {
    /**
     *
     * @type {string}
     * @memberof StrategyDetailsIn
     */
    strategyId: string;
}
/**
 *
 * @export
 * @interface StrategyDetailsOut
 */
export interface StrategyDetailsOut {
    /**
     *
     * @type {string}
     * @memberof StrategyDetailsOut
     */
    strategyId: string;
    /**
     *
     * @type {StrategyDetails}
     * @memberof StrategyDetailsOut
     */
    strategyDetails: StrategyDetails;
}
/**
 *
 * @export
 * @interface StrategyIn
 */
export interface StrategyIn {
    /**
     *
     * @type {string}
     * @memberof StrategyIn
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof StrategyIn
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof StrategyIn
     */
    url: string;
}
/**
 *
 * @export
 * @interface StrategyListCustomerIn
 */
export interface StrategyListCustomerIn {
    /**
     *
     * @type {string}
     * @memberof StrategyListCustomerIn
     */
    customerId: string;
}
/**
 *
 * @export
 * @interface StrategyListCustomerOut
 */
export interface StrategyListCustomerOut {
    /**
     *
     * @type {string}
     * @memberof StrategyListCustomerOut
     */
    customerId: string;
    /**
     *
     * @type {Array<StrategyDefinition>}
     * @memberof StrategyListCustomerOut
     */
    list: Array<StrategyDefinition>;
}
/**
 *
 * @export
 * @interface StrategyListOut
 */
export interface StrategyListOut {
    /**
     *
     * @type {Array<StrategyDefinition>}
     * @memberof StrategyListOut
     */
    list: Array<StrategyDefinition>;
}
/**
 *
 * @export
 * @interface StrategyOut
 */
export interface StrategyOut {
    /**
     *
     * @type {boolean}
     * @memberof StrategyOut
     */
    created: boolean;
}
/**
 *
 * @export
 * @interface StrategySubscriptionAdminIn
 */
export interface StrategySubscriptionAdminIn {
    /**
     *
     * @type {string}
     * @memberof StrategySubscriptionAdminIn
     */
    customerId: string;
    /**
     *
     * @type {string}
     * @memberof StrategySubscriptionAdminIn
     */
    strategyId: string;
    /**
     *
     * @type {string}
     * @memberof StrategySubscriptionAdminIn
     */
    channel: string;
    /**
     *
     * @type {SubscriptionConf}
     * @memberof StrategySubscriptionAdminIn
     */
    subscriptionConf: SubscriptionConf;
}
/**
 *
 * @export
 * @interface StrategySubscriptionCustomerIn
 */
export interface StrategySubscriptionCustomerIn {
    /**
     *
     * @type {string}
     * @memberof StrategySubscriptionCustomerIn
     */
    strategyId: string;
    /**
     *
     * @type {string}
     * @memberof StrategySubscriptionCustomerIn
     */
    channel: string;
    /**
     *
     * @type {SubscriptionConf}
     * @memberof StrategySubscriptionCustomerIn
     */
    subscriptionConf: SubscriptionConf;
}
/**
 *
 * @export
 * @interface StrategySubscriptionCustomerOut
 */
export interface StrategySubscriptionCustomerOut {
    /**
     *
     * @type {SubscriptionExt}
     * @memberof StrategySubscriptionCustomerOut
     */
    subscription: SubscriptionExt;
}
/**
 *
 * @export
 * @interface StrategySymbolOut
 */
export interface StrategySymbolOut {
    /**
     *
     * @type {Array<StrategySymbols>}
     * @memberof StrategySymbolOut
     */
    list: Array<StrategySymbols>;
}
/**
 *
 * @export
 * @interface StrategySymbols
 */
export interface StrategySymbols {
    /**
     *
     * @type {string}
     * @memberof StrategySymbols
     */
    provider: string;
    /**
     *
     * @type {string}
     * @memberof StrategySymbols
     */
    exchange: string;
    /**
     *
     * @type {string}
     * @memberof StrategySymbols
     */
    symbol: string;
    /**
     *
     * @type {boolean}
     * @memberof StrategySymbols
     */
    active: boolean;
}
/**
 *
 * @export
 * @interface StrategyTimeFrameOut
 */
export interface StrategyTimeFrameOut {
    /**
     *
     * @type {Array<StrategyTimeframe>}
     * @memberof StrategyTimeFrameOut
     */
    list: Array<StrategyTimeframe>;
}
/**
 *
 * @export
 * @interface StrategyTimeframe
 */
export interface StrategyTimeframe {
    /**
     *
     * @type {string}
     * @memberof StrategyTimeframe
     */
    timeframe: string;
}
/**
 *
 * @export
 * @interface SubscriptionConf
 */
export interface SubscriptionConf {
    /**
     *
     * @type {Array<SubscriptionListParameters>}
     * @memberof SubscriptionConf
     */
    listParameters: Array<SubscriptionListParameters>;
    /**
     *
     * @type {Array<ListSubsConf>}
     * @memberof SubscriptionConf
     */
    listSubsConf: Array<ListSubsConf>;
}
/**
 *
 * @export
 * @interface SubscriptionExt
 */
export interface SubscriptionExt {
    /**
     *
     * @type {string}
     * @memberof SubscriptionExt
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof SubscriptionExt
     */
    strategies_id: string;
    /**
     *
     * @type {string}
     * @memberof SubscriptionExt
     */
    user_id: string;
    /**
     *
     * @type {string}
     * @memberof SubscriptionExt
     */
    channel_id: string;
    /**
     *
     * @type {SubscriptionConf}
     * @memberof SubscriptionExt
     */
    subscriptionConf: SubscriptionConf;
}
/**
 *
 * @export
 * @interface SubscriptionListParameters
 */
export interface SubscriptionListParameters {
    /**
     *
     * @type {string}
     * @memberof SubscriptionListParameters
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof SubscriptionListParameters
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof SubscriptionListParameters
     */
    typeP: string;
}
/**
 *
 * @export
 * @interface UpdateSubscriptionIn
 */
export interface UpdateSubscriptionIn {
    /**
     *
     * @type {string}
     * @memberof UpdateSubscriptionIn
     */
    subcription_id: string;
    /**
     *
     * @type {string}
     * @memberof UpdateSubscriptionIn
     */
    customerId: string;
    /**
     *
     * @type {string}
     * @memberof UpdateSubscriptionIn
     */
    strategyId: string;
    /**
     *
     * @type {string}
     * @memberof UpdateSubscriptionIn
     */
    channel: string;
    /**
     *
     * @type {SubscriptionConf}
     * @memberof UpdateSubscriptionIn
     */
    subscriptionConf: SubscriptionConf;
}
/**
 *
 * @export
 * @interface UpdateSubscriptionOut
 */
export interface UpdateSubscriptionOut {
    /**
     *
     * @type {SubscriptionExt}
     * @memberof UpdateSubscriptionOut
     */
    subscription: SubscriptionExt;
}
/**
 *
 * @export
 * @interface UpdateUserIN
 */
export interface UpdateUserIN {
    /**
     *
     * @type {string}
     * @memberof UpdateUserIN
     */
    login: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserIN
     */
    email: string;
}

/**
 * PasswordresetApi - axios parameter creator
 * @export
 */
export const PasswordresetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {ForgotPasswordIN} forgotPasswordIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPasswordresetForgot: async (forgotPasswordIN: ForgotPasswordIN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordIN' is not null or undefined
            if (forgotPasswordIN === null || forgotPasswordIN === undefined) {
                throw new RequiredError('forgotPasswordIN','Required parameter forgotPasswordIN was null or undefined when calling postPasswordresetForgot.');
            }
            const localVarPath = `/passwordreset/forgot`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarQueryParameter = {} as any;
            const localVarHeaderParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof forgotPasswordIN !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(forgotPasswordIN !== undefined ? forgotPasswordIN : {}) : (forgotPasswordIN || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {PasswordResetIN} passwordResetIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPasswordresetReset: async (passwordResetIN: PasswordResetIN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordResetIN' is not null or undefined
            if (passwordResetIN === null || passwordResetIN === undefined) {
                throw new RequiredError('passwordResetIN','Required parameter passwordResetIN was null or undefined when calling postPasswordresetReset.');
            }
            const localVarPath = `/passwordreset/reset`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof passwordResetIN !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(passwordResetIN !== undefined ? passwordResetIN : {}) : (passwordResetIN || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordresetApi - functional programming interface
 * @export
 */
export const PasswordresetApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {ForgotPasswordIN} forgotPasswordIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPasswordresetForgot(forgotPasswordIN: ForgotPasswordIN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await PasswordresetApiAxiosParamCreator(configuration).postPasswordresetForgot(forgotPasswordIN, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {PasswordResetIN} passwordResetIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPasswordresetReset(passwordResetIN: PasswordResetIN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await PasswordresetApiAxiosParamCreator(configuration).postPasswordresetReset(passwordResetIN, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PasswordresetApi - factory interface
 * @export
 */
export const PasswordresetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @param {ForgotPasswordIN} forgotPasswordIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPasswordresetForgot(forgotPasswordIN: ForgotPasswordIN, options?: any): AxiosPromise<object> {
            return PasswordresetApiFp(configuration).postPasswordresetForgot(forgotPasswordIN, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PasswordResetIN} passwordResetIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPasswordresetReset(passwordResetIN: PasswordResetIN, options?: any): AxiosPromise<object> {
            return PasswordresetApiFp(configuration).postPasswordresetReset(passwordResetIN, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PasswordresetApi - object-oriented interface
 * @export
 * @class PasswordresetApi
 * @extends {BaseAPI}
 */
export class PasswordresetApi extends BaseAPI {
    /**
     *
     * @param {ForgotPasswordIN} forgotPasswordIN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordresetApi
     */
    public postPasswordresetForgot(forgotPasswordIN: ForgotPasswordIN, options?: any) {
        return PasswordresetApiFp(this.configuration).postPasswordresetForgot(forgotPasswordIN, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {PasswordResetIN} passwordResetIN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordresetApi
     */
    public postPasswordresetReset(passwordResetIN: PasswordResetIN, options?: any) {
        return PasswordresetApiFp(this.configuration).postPasswordresetReset(passwordResetIN, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProvidersApi - axios parameter creator
 * @export
 */
export const ProvidersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get list of coins generic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersCoinslist: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers/coinslist`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of exchanges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersExhangelist: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers/exhangeList`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of providers coins generic
         * @param {string} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersProviderscoinslist: async (body: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getProvidersProviderscoinslist.');
            }
            const localVarPath = `/providers/providerscoinslist`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersProviderslist: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers/providerslist`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvidersApi - functional programming interface
 * @export
 */
export const ProvidersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get list of coins generic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProvidersCoinslist(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoinsOut>> {
            const localVarAxiosArgs = await ProvidersApiAxiosParamCreator(configuration).getProvidersCoinslist(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get list of exchanges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProvidersExhangelist(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvidersOut>> {
            const localVarAxiosArgs = await ProvidersApiAxiosParamCreator(configuration).getProvidersExhangelist(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get list of providers coins generic
         * @param {string} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProvidersProviderscoinslist(body: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvidersCoinsOut>> {
            const localVarAxiosArgs = await ProvidersApiAxiosParamCreator(configuration).getProvidersProviderscoinslist(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get list of providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProvidersProviderslist(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvidersListOut>> {
            const localVarAxiosArgs = await ProvidersApiAxiosParamCreator(configuration).getProvidersProviderslist(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProvidersApi - factory interface
 * @export
 */
export const ProvidersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get list of coins generic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersCoinslist(options?: any): AxiosPromise<CoinsOut> {
            return ProvidersApiFp(configuration).getProvidersCoinslist(options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of exchanges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersExhangelist(options?: any): AxiosPromise<ProvidersOut> {
            return ProvidersApiFp(configuration).getProvidersExhangelist(options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of providers coins generic
         * @param {string} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersProviderscoinslist(body: string, options?: any): AxiosPromise<ProvidersCoinsOut> {
            return ProvidersApiFp(configuration).getProvidersProviderscoinslist(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersProviderslist(options?: any): AxiosPromise<ProvidersListOut> {
            return ProvidersApiFp(configuration).getProvidersProviderslist(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvidersApi - object-oriented interface
 * @export
 * @class ProvidersApi
 * @extends {BaseAPI}
 */
export class ProvidersApi extends BaseAPI {
    /**
     * Get list of coins generic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public getProvidersCoinslist(options?: any) {
        return ProvidersApiFp(this.configuration).getProvidersCoinslist(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of exchanges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public getProvidersExhangelist(options?: any) {
        return ProvidersApiFp(this.configuration).getProvidersExhangelist(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of providers coins generic
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public getProvidersProviderscoinslist(body: string, options?: any) {
        return ProvidersApiFp(this.configuration).getProvidersProviderscoinslist(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public getProvidersProviderslist(options?: any) {
        return ProvidersApiFp(this.configuration).getProvidersProviderslist(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StrategyApi - axios parameter creator
 * @export
 */
export const StrategyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get list of strategies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyListStrategy: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/strategy/list_strategy`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of strategy symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyListSymbols: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/strategy/list_symbols`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of time frames
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyListTimeframe: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/strategy/list_timeframe`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a strategy. Define the name, must be unique. Add a description and the the url of the image
         * @param {StrategyIn} strategyIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStrategyCreateStrategyAdmin: async (strategyIn: StrategyIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'strategyIn' is not null or undefined
            if (strategyIn === null || strategyIn === undefined) {
                throw new RequiredError('strategyIn','Required parameter strategyIn was null or undefined when calling postStrategyCreateStrategyAdmin.');
            }
            const localVarPath = `/strategy/create_strategy_admin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof strategyIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(strategyIn !== undefined ? strategyIn : {}) : (strategyIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Strategy details
         * @param {StrategyDetailsIn} strategyDetailsIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStrategyDetailStrategy: async (strategyDetailsIn: StrategyDetailsIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'strategyDetailsIn' is not null or undefined
            if (strategyDetailsIn === null || strategyDetailsIn === undefined) {
                throw new RequiredError('strategyDetailsIn','Required parameter strategyDetailsIn was null or undefined when calling postStrategyDetailStrategy.');
            }
            const localVarPath = `/strategy/detail_strategy`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof strategyDetailsIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(strategyDetailsIn !== undefined ? strategyDetailsIn : {}) : (strategyDetailsIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of strategies by Customers. Admin tasks. Can see all strategies
         * @param {StrategyListCustomerIn} strategyListCustomerIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStrategyListStrategyByCustomer: async (strategyListCustomerIn: StrategyListCustomerIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'strategyListCustomerIn' is not null or undefined
            if (strategyListCustomerIn === null || strategyListCustomerIn === undefined) {
                throw new RequiredError('strategyListCustomerIn','Required parameter strategyListCustomerIn was null or undefined when calling postStrategyListStrategyByCustomer.');
            }
            const localVarPath = `/strategy/list_strategy_by_customer`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof strategyListCustomerIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(strategyListCustomerIn !== undefined ? strategyListCustomerIn : {}) : (strategyListCustomerIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StrategyApi - functional programming interface
 * @export
 */
export const StrategyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get list of strategies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStrategyListStrategy(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyListOut>> {
            const localVarAxiosArgs = await StrategyApiAxiosParamCreator(configuration).getStrategyListStrategy(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get list of strategy symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStrategyListSymbols(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategySymbolOut>> {
            const localVarAxiosArgs = await StrategyApiAxiosParamCreator(configuration).getStrategyListSymbols(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get list of time frames
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStrategyListTimeframe(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyTimeFrameOut>> {
            const localVarAxiosArgs = await StrategyApiAxiosParamCreator(configuration).getStrategyListTimeframe(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a strategy. Define the name, must be unique. Add a description and the the url of the image
         * @param {StrategyIn} strategyIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStrategyCreateStrategyAdmin(strategyIn: StrategyIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyOut>> {
            const localVarAxiosArgs = await StrategyApiAxiosParamCreator(configuration).postStrategyCreateStrategyAdmin(strategyIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Strategy details
         * @param {StrategyDetailsIn} strategyDetailsIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStrategyDetailStrategy(strategyDetailsIn: StrategyDetailsIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyDetailsOut>> {
            const localVarAxiosArgs = await StrategyApiAxiosParamCreator(configuration).postStrategyDetailStrategy(strategyDetailsIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get list of strategies by Customers. Admin tasks. Can see all strategies
         * @param {StrategyListCustomerIn} strategyListCustomerIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStrategyListStrategyByCustomer(strategyListCustomerIn: StrategyListCustomerIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyListCustomerOut>> {
            const localVarAxiosArgs = await StrategyApiAxiosParamCreator(configuration).postStrategyListStrategyByCustomer(strategyListCustomerIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StrategyApi - factory interface
 * @export
 */
export const StrategyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get list of strategies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyListStrategy(options?: any): AxiosPromise<StrategyListOut> {
            return StrategyApiFp(configuration).getStrategyListStrategy(options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of strategy symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyListSymbols(options?: any): AxiosPromise<StrategySymbolOut> {
            return StrategyApiFp(configuration).getStrategyListSymbols(options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of time frames
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyListTimeframe(options?: any): AxiosPromise<StrategyTimeFrameOut> {
            return StrategyApiFp(configuration).getStrategyListTimeframe(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a strategy. Define the name, must be unique. Add a description and the the url of the image
         * @param {StrategyIn} strategyIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStrategyCreateStrategyAdmin(strategyIn: StrategyIn, options?: any): AxiosPromise<StrategyOut> {
            return StrategyApiFp(configuration).postStrategyCreateStrategyAdmin(strategyIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Strategy details
         * @param {StrategyDetailsIn} strategyDetailsIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStrategyDetailStrategy(strategyDetailsIn: StrategyDetailsIn, options?: any): AxiosPromise<StrategyDetailsOut> {
            return StrategyApiFp(configuration).postStrategyDetailStrategy(strategyDetailsIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of strategies by Customers. Admin tasks. Can see all strategies
         * @param {StrategyListCustomerIn} strategyListCustomerIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStrategyListStrategyByCustomer(strategyListCustomerIn: StrategyListCustomerIn, options?: any): AxiosPromise<StrategyListCustomerOut> {
            return StrategyApiFp(configuration).postStrategyListStrategyByCustomer(strategyListCustomerIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StrategyApi - object-oriented interface
 * @export
 * @class StrategyApi
 * @extends {BaseAPI}
 */
export class StrategyApi extends BaseAPI {
    /**
     * Get list of strategies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategyApi
     */
    public getStrategyListStrategy(options?: any) {
        return StrategyApiFp(this.configuration).getStrategyListStrategy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of strategy symbols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategyApi
     */
    public getStrategyListSymbols(options?: any) {
        return StrategyApiFp(this.configuration).getStrategyListSymbols(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of time frames
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategyApi
     */
    public getStrategyListTimeframe(options?: any) {
        return StrategyApiFp(this.configuration).getStrategyListTimeframe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a strategy. Define the name, must be unique. Add a description and the the url of the image
     * @param {StrategyIn} strategyIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategyApi
     */
    public postStrategyCreateStrategyAdmin(strategyIn: StrategyIn, options?: any) {
        return StrategyApiFp(this.configuration).postStrategyCreateStrategyAdmin(strategyIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Strategy details
     * @param {StrategyDetailsIn} strategyDetailsIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategyApi
     */
    public postStrategyDetailStrategy(strategyDetailsIn: StrategyDetailsIn, options?: any) {
        return StrategyApiFp(this.configuration).postStrategyDetailStrategy(strategyDetailsIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of strategies by Customers. Admin tasks. Can see all strategies
     * @param {StrategyListCustomerIn} strategyListCustomerIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategyApi
     */
    public postStrategyListStrategyByCustomer(strategyListCustomerIn: StrategyListCustomerIn, options?: any) {
        return StrategyApiFp(this.configuration).postStrategyListStrategyByCustomer(strategyListCustomerIn, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SubscriptionApi - axios parameter creator
 * @export
 */
export const SubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete all subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDeleteAllSubscriptions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscription/delete_all_subscriptions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionListSubscription: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscription/list_subscription`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscription to a strategy by Customers.
         * @param {StrategySubscriptionCustomerIn} strategySubscriptionCustomerIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionCreateSubscription: async (strategySubscriptionCustomerIn: StrategySubscriptionCustomerIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'strategySubscriptionCustomerIn' is not null or undefined
            if (strategySubscriptionCustomerIn === null || strategySubscriptionCustomerIn === undefined) {
                throw new RequiredError('strategySubscriptionCustomerIn','Required parameter strategySubscriptionCustomerIn was null or undefined when calling postSubscriptionCreateSubscription.');
            }
            const localVarPath = `/subscription/create_subscription`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof strategySubscriptionCustomerIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(strategySubscriptionCustomerIn !== undefined ? strategySubscriptionCustomerIn : {}) : (strategySubscriptionCustomerIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscription to a strategy by Customers. Admin can subscribe a user to a strategy
         * @param {StrategySubscriptionAdminIn} strategySubscriptionAdminIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionCreateSubscriptionByadmin: async (strategySubscriptionAdminIn: StrategySubscriptionAdminIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'strategySubscriptionAdminIn' is not null or undefined
            if (strategySubscriptionAdminIn === null || strategySubscriptionAdminIn === undefined) {
                throw new RequiredError('strategySubscriptionAdminIn','Required parameter strategySubscriptionAdminIn was null or undefined when calling postSubscriptionCreateSubscriptionByadmin.');
            }
            const localVarPath = `/subscription/create_subscription_byadmin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof strategySubscriptionAdminIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(strategySubscriptionAdminIn !== undefined ? strategySubscriptionAdminIn : {}) : (strategySubscriptionAdminIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a subscription
         * @param {DeleteSubscriptionIn} deleteSubscriptionIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionDeleteOneSubscription: async (deleteSubscriptionIn: DeleteSubscriptionIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteSubscriptionIn' is not null or undefined
            if (deleteSubscriptionIn === null || deleteSubscriptionIn === undefined) {
                throw new RequiredError('deleteSubscriptionIn','Required parameter deleteSubscriptionIn was null or undefined when calling postSubscriptionDeleteOneSubscription.');
            }
            const localVarPath = `/subscription/delete_one_subscription`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deleteSubscriptionIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deleteSubscriptionIn !== undefined ? deleteSubscriptionIn : {}) : (deleteSubscriptionIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a subscription
         * @param {UpdateSubscriptionIn} updateSubscriptionIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionUpdateSubscription: async (updateSubscriptionIn: UpdateSubscriptionIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateSubscriptionIn' is not null or undefined
            if (updateSubscriptionIn === null || updateSubscriptionIn === undefined) {
                throw new RequiredError('updateSubscriptionIn','Required parameter updateSubscriptionIn was null or undefined when calling postSubscriptionUpdateSubscription.');
            }
            const localVarPath = `/subscription/update_subscription`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateSubscriptionIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateSubscriptionIn !== undefined ? updateSubscriptionIn : {}) : (updateSubscriptionIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionApi - functional programming interface
 * @export
 */
export const SubscriptionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete all subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionDeleteAllSubscriptions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAllSubscriptionsOut>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).getSubscriptionDeleteAllSubscriptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionListSubscription(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSubscriptionOut>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).getSubscriptionListSubscription(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Subscription to a strategy by Customers.
         * @param {StrategySubscriptionCustomerIn} strategySubscriptionCustomerIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSubscriptionCreateSubscription(strategySubscriptionCustomerIn: StrategySubscriptionCustomerIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategySubscriptionCustomerOut>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).postSubscriptionCreateSubscription(strategySubscriptionCustomerIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Subscription to a strategy by Customers. Admin can subscribe a user to a strategy
         * @param {StrategySubscriptionAdminIn} strategySubscriptionAdminIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSubscriptionCreateSubscriptionByadmin(strategySubscriptionAdminIn: StrategySubscriptionAdminIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategySubscriptionCustomerOut>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).postSubscriptionCreateSubscriptionByadmin(strategySubscriptionAdminIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a subscription
         * @param {DeleteSubscriptionIn} deleteSubscriptionIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSubscriptionDeleteOneSubscription(deleteSubscriptionIn: DeleteSubscriptionIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteSubscriptionOut>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).postSubscriptionDeleteOneSubscription(deleteSubscriptionIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a subscription
         * @param {UpdateSubscriptionIn} updateSubscriptionIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSubscriptionUpdateSubscription(updateSubscriptionIn: UpdateSubscriptionIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateSubscriptionOut>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).postSubscriptionUpdateSubscription(updateSubscriptionIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SubscriptionApi - factory interface
 * @export
 */
export const SubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete all subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDeleteAllSubscriptions(options?: any): AxiosPromise<DeleteAllSubscriptionsOut> {
            return SubscriptionApiFp(configuration).getSubscriptionDeleteAllSubscriptions(options).then((request) => request(axios, basePath));
        },
        /**
         * Get subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionListSubscription(options?: any): AxiosPromise<ListSubscriptionOut> {
            return SubscriptionApiFp(configuration).getSubscriptionListSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * Subscription to a strategy by Customers.
         * @param {StrategySubscriptionCustomerIn} strategySubscriptionCustomerIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionCreateSubscription(strategySubscriptionCustomerIn: StrategySubscriptionCustomerIn, options?: any): AxiosPromise<StrategySubscriptionCustomerOut> {
            return SubscriptionApiFp(configuration).postSubscriptionCreateSubscription(strategySubscriptionCustomerIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Subscription to a strategy by Customers. Admin can subscribe a user to a strategy
         * @param {StrategySubscriptionAdminIn} strategySubscriptionAdminIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionCreateSubscriptionByadmin(strategySubscriptionAdminIn: StrategySubscriptionAdminIn, options?: any): AxiosPromise<StrategySubscriptionCustomerOut> {
            return SubscriptionApiFp(configuration).postSubscriptionCreateSubscriptionByadmin(strategySubscriptionAdminIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a subscription
         * @param {DeleteSubscriptionIn} deleteSubscriptionIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionDeleteOneSubscription(deleteSubscriptionIn: DeleteSubscriptionIn, options?: any): AxiosPromise<DeleteSubscriptionOut> {
            return SubscriptionApiFp(configuration).postSubscriptionDeleteOneSubscription(deleteSubscriptionIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a subscription
         * @param {UpdateSubscriptionIn} updateSubscriptionIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionUpdateSubscription(updateSubscriptionIn: UpdateSubscriptionIn, options?: any): AxiosPromise<UpdateSubscriptionOut> {
            return SubscriptionApiFp(configuration).postSubscriptionUpdateSubscription(updateSubscriptionIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
export class SubscriptionApi extends BaseAPI {
    /**
     * Delete all subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionDeleteAllSubscriptions(options?: any) {
        return SubscriptionApiFp(this.configuration).getSubscriptionDeleteAllSubscriptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionListSubscription(options?: any) {
        return SubscriptionApiFp(this.configuration).getSubscriptionListSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subscription to a strategy by Customers.
     * @param {StrategySubscriptionCustomerIn} strategySubscriptionCustomerIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public postSubscriptionCreateSubscription(strategySubscriptionCustomerIn: StrategySubscriptionCustomerIn, options?: any) {
        return SubscriptionApiFp(this.configuration).postSubscriptionCreateSubscription(strategySubscriptionCustomerIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subscription to a strategy by Customers. Admin can subscribe a user to a strategy
     * @param {StrategySubscriptionAdminIn} strategySubscriptionAdminIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public postSubscriptionCreateSubscriptionByadmin(strategySubscriptionAdminIn: StrategySubscriptionAdminIn, options?: any) {
        return SubscriptionApiFp(this.configuration).postSubscriptionCreateSubscriptionByadmin(strategySubscriptionAdminIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a subscription
     * @param {DeleteSubscriptionIn} deleteSubscriptionIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public postSubscriptionDeleteOneSubscription(deleteSubscriptionIn: DeleteSubscriptionIn, options?: any) {
        return SubscriptionApiFp(this.configuration).postSubscriptionDeleteOneSubscription(deleteSubscriptionIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a subscription
     * @param {UpdateSubscriptionIn} updateSubscriptionIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public postSubscriptionUpdateSubscription(updateSubscriptionIn: UpdateSubscriptionIn, options?: any) {
        return SubscriptionApiFp(this.configuration).postSubscriptionUpdateSubscription(updateSubscriptionIn, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {UpdateUserIN} updateUserIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser: async (updateUserIN: UpdateUserIN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserIN' is not null or undefined
            if (updateUserIN === null || updateUserIN === undefined) {
                throw new RequiredError('updateUserIN','Required parameter updateUserIN was null or undefined when calling postUser.');
            }
            const localVarPath = `/user`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateUserIN !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateUserIN !== undefined ? updateUserIN : {}) : (updateUserIN || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {ChangePasswordIN} changePasswordIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserChangepassword: async (changePasswordIN: ChangePasswordIN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordIN' is not null or undefined
            if (changePasswordIN === null || changePasswordIN === undefined) {
                throw new RequiredError('changePasswordIN','Required parameter changePasswordIN was null or undefined when calling postUserChangepassword.');
            }
            const localVarPath = `/user/changepassword`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof changePasswordIN !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(changePasswordIN !== undefined ? changePasswordIN : {}) : (changePasswordIN || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {LoginIN} loginIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserLogin: async (loginIN: LoginIN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginIN' is not null or undefined
            if (loginIN === null || loginIN === undefined) {
                throw new RequiredError('loginIN','Required parameter loginIN was null or undefined when calling postUserLogin.');
            }
            const localVarPath = `/user/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof loginIN !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(loginIN !== undefined ? loginIN : {}) : (loginIN || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {RegisterIN} registerIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserRegister: async (registerIN: RegisterIN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerIN' is not null or undefined
            if (registerIN === null || registerIN === undefined) {
                throw new RequiredError('registerIN','Required parameter registerIN was null or undefined when calling postUserRegister.');
            }
            const localVarPath = `/user/register`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof registerIN !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(registerIN !== undefined ? registerIN : {}) : (registerIN || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserOUT>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {UpdateUserIN} updateUserIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUser(updateUserIN: UpdateUserIN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).postUser(updateUserIN, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {ChangePasswordIN} changePasswordIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserChangepassword(changePasswordIN: ChangePasswordIN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).postUserChangepassword(changePasswordIN, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {LoginIN} loginIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserLogin(loginIN: LoginIN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginOUT>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).postUserLogin(loginIN, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {RegisterIN} registerIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserRegister(registerIN: RegisterIN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterOUT>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).postUserRegister(registerIN, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<GetUserOUT> {
            return UserApiFp(configuration).getUser(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UpdateUserIN} updateUserIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser(updateUserIN: UpdateUserIN, options?: any): AxiosPromise<object> {
            return UserApiFp(configuration).postUser(updateUserIN, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ChangePasswordIN} changePasswordIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserChangepassword(changePasswordIN: ChangePasswordIN, options?: any): AxiosPromise<object> {
            return UserApiFp(configuration).postUserChangepassword(changePasswordIN, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {LoginIN} loginIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserLogin(loginIN: LoginIN, options?: any): AxiosPromise<LoginOUT> {
            return UserApiFp(configuration).postUserLogin(loginIN, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {RegisterIN} registerIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserRegister(registerIN: RegisterIN, options?: any): AxiosPromise<RegisterOUT> {
            return UserApiFp(configuration).postUserRegister(registerIN, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: any) {
        return UserApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {UpdateUserIN} updateUserIN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postUser(updateUserIN: UpdateUserIN, options?: any) {
        return UserApiFp(this.configuration).postUser(updateUserIN, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {ChangePasswordIN} changePasswordIN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postUserChangepassword(changePasswordIN: ChangePasswordIN, options?: any) {
        return UserApiFp(this.configuration).postUserChangepassword(changePasswordIN, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {LoginIN} loginIN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postUserLogin(loginIN: LoginIN, options?: any) {
        return UserApiFp(this.configuration).postUserLogin(loginIN, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {RegisterIN} registerIN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postUserRegister(registerIN: RegisterIN, options?: any) {
        return UserApiFp(this.configuration).postUserRegister(registerIN, options).then((request) => request(this.axios, this.basePath));
    }

}


